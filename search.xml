<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python分析预测股价</title>
      <link href="/2019/01/20/Python%E5%88%86%E6%9E%90%E9%A2%84%E6%B5%8B%E8%82%A1%E4%BB%B7/"/>
      <url>/2019/01/20/Python%E5%88%86%E6%9E%90%E9%A2%84%E6%B5%8B%E8%82%A1%E4%BB%B7/</url>
      
        <content type="html"><![CDATA[<p>提示：本文中使用Linear Regression模型，股票数据来自Quandl库，需要安装。(预测不靠谱仅仅是作为一个练手项目，切勿用于实际操作)</p><p>Quandl可以免费使用，但是下载数据或一天调用超过50次需要身份认证。要想获得认证，需要在<a href="http://link.zhihu.com/?target=https%3A//www.quandl.com/" target="_blank" rel="noopener">官网</a>注册账号，获得API key，在使用中加入如下代码：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quandl.ApiConfig.api_key = &quot;YOURAPIKEY&quot; #YOURAPIKEY替换成你的API key(在官网个人信息中)</span><br></pre></td></tr></table></figure><p>Quandl的详细使用说明请参考官方文档：</p><p>[<a href="https://docs.quandl.com/docs/python]" target="_blank" rel="noopener">https://docs.quandl.com/docs/python]</a>: </p><a id="more"></a><h2 id="查询并显示历史股价信息"><a href="#查询并显示历史股价信息" class="headerlink" title="查询并显示历史股价信息"></a>查询并显示历史股价信息</h2><p>以苹果公司为例，以下为示例：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#数据分析基本都将numpy和pandas引入为np，pd。模块的安装可搜索python教程</span><br><span class="line">import datetime</span><br><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">import quandl, math</span><br><span class="line">import sklearn</span><br><span class="line">from sklearn.linear_model import LinearRegression</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from matplotlib import style</span><br><span class="line"></span><br><span class="line">#获取苹果股价历史数据</span><br><span class="line">df = quandl.get(&quot;WIKI/AAPL&quot;)</span><br><span class="line"></span><br><span class="line">#打印几行数据</span><br><span class="line">print(df.head())</span><br><span class="line"></span><br><span class="line">#显示苹果的Adj. Close变化趋势，从上一行打印出的信息中选择Adj. Close（收盘价）这一项来作图</span><br><span class="line">df[&apos;Adj. Close&apos;].plot()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#print(df.head())打印得数据如下</span><br><span class="line"></span><br><span class="line">             Open   High    Low  ...  Adj. Low  Adj. Close  Adj. Volume</span><br><span class="line">Date                             ...                                   </span><br><span class="line">1980-12-12  28.75  28.87  28.75  ...  0.422706    0.422706  117258400.0</span><br><span class="line">1980-12-15  27.38  27.38  27.25  ...  0.400652    0.400652   43971200.0</span><br><span class="line">1980-12-16  25.37  25.37  25.25  ...  0.371246    0.371246   26432000.0</span><br><span class="line">1980-12-17  25.87  26.00  25.87  ...  0.380362    0.380362   21610400.0</span><br><span class="line">1980-12-18  26.63  26.75  26.63  ...  0.391536    0.391536   18362400.0</span><br><span class="line"></span><br><span class="line">[5 rows x 12 columns]</span><br></pre></td></tr></table></figure><h2 id="选择训练集，测试集然后进行预测"><a href="#选择训练集，测试集然后进行预测" class="headerlink" title="选择训练集，测试集然后进行预测"></a>选择训练集，测试集然后进行预测</h2><p>训练集和测试集是机器学习的基本概念，简单来说就是一部分数据用于测试一部分数据用于验证，如果你用训练的数据进行验证，那结果就没有意义了。下面是完整源码，</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">import datetime</span><br><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">import quandl, math</span><br><span class="line">from sklearn import preprocessing, model_selection, svm</span><br><span class="line">from sklearn.linear_model import LinearRegression</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from matplotlib import style</span><br><span class="line"></span><br><span class="line">#下载历史数据</span><br><span class="line">df = quandl.get(&quot;WIKI/AAPL&quot;)</span><br><span class="line">print(df.head())</span><br><span class="line">#提取历史数据的后1%用来进行预测</span><br><span class="line">#计算历史数据1%的数值</span><br><span class="line">forecast = int(math.ceil(0.01 * len(df)))</span><br><span class="line">forecast_df = df[-forecast:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#提取历史数据的剩余部分用来训练和测试模型表现</span><br><span class="line">AAPL = df[:-forecast]</span><br><span class="line">#把label以外的字段作为特征X</span><br><span class="line">X = np.array(AAPL.drop([&apos;Adj. Close&apos;], 1))</span><br><span class="line">#设置Adj. Clos字段为目标值y</span><br><span class="line">y = np.array(AAPL[&apos;Adj. Close&apos;])</span><br><span class="line">#划分训练集和测试集，测试集占比20%，训练集占比80%</span><br><span class="line">X_train, X_test, y_train, y_test = model_selection.train_test_split(X, y, test_size=0.2)</span><br><span class="line"></span><br><span class="line">#使用训练集数据对模型进行训练</span><br><span class="line">clf = LinearRegression(n_jobs=-1)</span><br><span class="line">clf.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">#使用测试集数据层查看模型准确率得分</span><br><span class="line">confidence = clf.score(X_test, y_test)</span><br><span class="line">print(confidence)</span><br><span class="line"></span><br><span class="line">#对1%的预留数据进行预测</span><br><span class="line">f_X=np.array(forecast_df.drop([&apos;Adj. Close&apos;], 1))</span><br><span class="line">forecast_set = clf.predict(f_X)</span><br><span class="line"></span><br><span class="line">#创建一个Forecast列存放预测值</span><br><span class="line">AAPL[&apos;Forecast&apos;] = np.nan</span><br><span class="line">#查看数据表中最后一条数据的日期</span><br><span class="line">last_date = AAPL.iloc[-1].name</span><br><span class="line">#将最后一条数据的日期转化为秒</span><br><span class="line">last_unix = last_date.timestamp()</span><br><span class="line">#一天等于86400秒</span><br><span class="line">one_day = 86400</span><br><span class="line">#下一天=数据表最后一天日期数值+一天的秒数值</span><br><span class="line">next_unix = last_unix + one_day</span><br><span class="line">#循环输出日期及预测值</span><br><span class="line">for i in forecast_set:</span><br><span class="line">    next_date = datetime.datetime.fromtimestamp(next_unix)</span><br><span class="line">    next_unix += 86400</span><br><span class="line">    AAPL.loc[next_date] = [np.nan for _ in range(len(AAPL.columns)-1)]+[i]</span><br><span class="line"></span><br><span class="line">#预测后的数据表</span><br><span class="line">print(AAPL.head())</span><br><span class="line">print(AAPL.tail())</span><br><span class="line"></span><br><span class="line">#对真实值和预测值可视化</span><br><span class="line">fig = plt.figure(figsize = (12,12))</span><br><span class="line">AAPL[&apos;Adj. Close&apos;].plot()</span><br><span class="line">AAPL[&apos;Forecast&apos;].plot()</span><br><span class="line">plt.legend(loc=4)</span><br><span class="line">plt.xlabel(&apos;Date&apos;)</span><br><span class="line">plt.ylabel(&apos;Price&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>最后绘制出的图形：</p><p><img src="https://s2.ax1x.com/2019/03/02/kbTwz8.jpg" alt="APPLE股价预测图"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据分析实例 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>需求的分析与管理</title>
      <link href="/2018/10/03/%E4%BA%A7%E5%93%81%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2018/10/03/%E4%BA%A7%E5%93%81%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p> 需求是产品经理每天接触最多的东西，总有要改的需求，总有新增的需求，本篇就来谈谈需求。</p><h2 id="什么是需求："><a href="#什么是需求：" class="headerlink" title="什么是需求："></a>什么是需求：</h2><h3 id="从用户的角度："><a href="#从用户的角度：" class="headerlink" title="从用户的角度："></a>从用户的角度：</h3><p>从用户的角度看，就是用户<strong>想要什么</strong>。</p><p>比如现在有个用户想要开窗。</p><h3 id="关注背景："><a href="#关注背景：" class="headerlink" title="关注背景："></a>关注背景：</h3><p>在了解了用户想要什么之后一定要关注<strong>背景</strong>，否则就容易给出<strong>治标不治本</strong>的解决方案。</p><p>比如现在这个用户的背景是在屋子里很热，汗流浃背。</p><h3 id="从产品经理的角度："><a href="#从产品经理的角度：" class="headerlink" title="从产品经理的角度："></a>从产品经理的角度：</h3><p>通过前两个角度的分析，我们发现用户的<strong>根本问题</strong>是屋子里太热了。</p><p>于是我可以选择给用户安装风扇空调，这就是解决方案。</p><a id="more"></a><h3 id="需求即用户产生问题的根本原因："><a href="#需求即用户产生问题的根本原因：" class="headerlink" title="需求即用户产生问题的根本原因："></a>需求即用户产生问题的根本原因：</h3><p>需求只于用户产生问题的<strong>根本原因</strong>有关。并不是一些<strong>表面的原因</strong>。</p><p>另一个很经典的例子：就是人跟人交流，传递信息。</p><p>解决方案的历史：喊-&gt;飞鸽传书-&gt;邮局-&gt;电报-&gt;电话-&gt;IM软件。</p><p>我们可以发现，用户的需求一直都是交流。</p><h3 id="需求与背景："><a href="#需求与背景：" class="headerlink" title="需求与背景："></a>需求与背景：</h3><p>需求必须与背景相匹配。在现在不会人人都会使用IM软件，不会有人使用飞鸽传书。</p><p>比如内燃机时代，用户说自己需要更快的马，于是我们就要去训练更好的马吗？</p><p>我们知道福特给出的方案是发明了汽车。因为用户的需求是更快的交通工具。</p><p>但是如果放到现代，一个用户家里有车，说自己需要更快的马。那么他很可能是马术爱好者，确实只是需要更好的马。</p><h3 id="需求层次理论："><a href="#需求层次理论：" class="headerlink" title="需求层次理论："></a>需求层次理论：</h3><blockquote><p>马斯洛的需求层次理论（英语：Maslow’s hierarchy of needs）是亚伯拉罕·马斯洛于1943年《心理学评论》的论文〈人类动机的理论〉（A Theory of Human Motivation）中所提出的理论[2]。马斯洛随后延伸了这个想法，包含了他对人类天生好奇心的观察。他的理论与其他人类发展心理学的理论可以并行，尤其是针对人类成长阶段的描述。马斯洛使用了“生理”、“安全”、“隶属”与“爱”、“自尊”、“自我实现”与“自我超越”等术语，描述人类动机推移的脉络。</p></blockquote><p><img src="https://s2.ax1x.com/2019/03/05/kXsomq.png" alt="马斯洛的需求层次模型"></p><p>一般来说，越是底层，需求就越大越强。产品可以在满足基本需要时，可以分析用户的马斯洛需求，进一步满足用户<strong>更高层次的需求</strong>，从而提升产品竞争力。</p><p>比如支付宝微信红包功能，红包上还能写祝福语，那么已经有转账功能了为什么还需要一个红包功能呢？</p><p>就是因为转账只能满足用户便捷和安全的需要，而红包能够更近一步的满足<strong>社交和情感化需求</strong>。</p><h2 id="如何寻找需求："><a href="#如何寻找需求：" class="headerlink" title="如何寻找需求："></a>如何寻找需求：</h2><p>用户的需求与冰山类似，我们只能看到少部分<strong>已知的需求</strong>，例如：用户热，所以我们提供空调。</p><p>一部分<strong>隐含的需求</strong>，例如：有人买奔驰，不仅仅是因为奔驰的车性能好，还隐含着他对社交的需求，对尊重的需求，还可能是炫耀，而这种需求一般不会说出来。</p><p>还有一部分<strong>未知的需求</strong>，比如要更快的马的人其实并不清楚自己要的是更快的交通工具。</p><p>所以在我们挖掘需求时，需要注重方法，尽可能的挖掘需求。</p><h3 id="需求调研："><a href="#需求调研：" class="headerlink" title="需求调研："></a>需求调研：</h3><p>需求调研大致可以总结为以下三步</p><p><strong>询问</strong>：找到关键问题，询问用户的看法。</p><p><strong>倾听</strong>：切记不要对用户的观点进行评价，评价会使用户不能真实表达，仅仅做好倾听者的角色。</p><p><strong>场景</strong>：分析用户场景，最好到用户所在场景中去调研，而不是把用户招来我们的办公室。</p><p><strong>行为</strong>：观察用户的真实行为，行为往往能更真实的反应用户的需求。</p><p>例：Sony在调研用户所喜欢的MP3的颜色，询问用户对不同颜色MP3的看法，大多数用户在谈到黑色时，</p><p>说黑色沉闷无趣。但Sony的高明之处在于，在调研活动结束时可以让被调研用户选择一个颜色的MP3带走。</p><p>这时，大部分用户却选择了黑色。再落实到场景，因为MP3是便携设备，大多数人要考虑带出去的情况，</p><p>而大和民族是一个不主张个性的民族，那么黑色就更贴合他们外出时的心理需求。</p><h3 id="找到刚需、频发的需求："><a href="#找到刚需、频发的需求：" class="headerlink" title="找到刚需、频发的需求："></a>找到刚需、频发的需求：</h3><p><strong>刚需</strong>，典型代表就是住房，高企的房价可以说明很多问题了。</p><p><strong>频发的需求</strong>，典型代表就是IM软件，我们日常需要不停的发消息，与人进行沟通。</p><p>满足这样的需求，才能带来客观的<strong>商业价值</strong>。</p><h3 id="分辨真假需求："><a href="#分辨真假需求：" class="headerlink" title="分辨真假需求："></a>分辨真假需求：</h3><p>有些功能做了绝大多数用户都不去使用，那么恭喜，你验证了一个假需求。</p><p>例如飞行航路图，绝大部分用户并不关心航线是怎样的，比起航线用户更关心时间等其他信息。</p><p>那么怎么去辨别呢？这里提供三个步骤</p><p><strong>观察需求是否普遍，分析需求发生背景，分析需求来源</strong>。</p><p>网络定票12306满足了人们出行的普遍需求。4G时代短视频APP的流行迎合了4G高速网络的背景。</p><p>以上两个例子都有深刻的需求来源，前者是出行，后者是娱乐。</p><p>这时这并不能绝对的判断是真还是假需求。</p><p>诺基亚的时代，iPhone还没出世，智能机的需求看起来并不普遍。</p><p>而在那时能推出iPhone的人，也成为了传奇。</p><h2 id="需求的管理："><a href="#需求的管理：" class="headerlink" title="需求的管理："></a>需求的管理：</h2><p>建模是思考的好方法，更能将问题抽象化。在管理需求时，我们引入卡诺模型。</p><h3 id="卡诺模型："><a href="#卡诺模型：" class="headerlink" title="卡诺模型："></a>卡诺模型：</h3><p><img src="https://s2.ax1x.com/2019/03/05/kXftRf.png" alt="卡诺模型"></p><p><strong>必备属性</strong>：基本必须功能。</p><p><strong>期望属性</strong>：用户想要的功能，产品越能提高这项属性，用户的满意度越高。</p><p><strong>魅力属性</strong>：用户没想到的功能，产品提供了令人惊喜的功能，用户满意度大幅提高。</p><p><strong>无差异特性</strong>：此特性不管做多做少，用户都不会在意。</p><p><strong>反向特性</strong>：如果产品中有此特性越多，用户越不满意。</p><p>我们可以将我们需要的功能的进行属性上的划分，以便管理。</p><p><img src="https://s2.ax1x.com/2019/03/05/kXfRQU.png" alt="卡诺模型表"></p><p>在用户满意度调查中也可以依据卡诺模型合理设置问题，得到绘制卡诺图所需要的数据。</p><h3 id="需求管理表："><a href="#需求管理表：" class="headerlink" title="需求管理表："></a>需求管理表：</h3><p>需求管理列表的几项要素：<strong>编号、优先级、商业价值、备注、状态、时间、描述、类型</strong></p><p>这里列举几个更为便捷的需求管理工具：</p><p><strong>Rational RequisitePro</strong></p><p><strong>IBM Rational DOORS</strong></p><p><strong>青铜器RDM</strong></p><h2 id="需求的规划"><a href="#需求的规划" class="headerlink" title="需求的规划"></a>需求的规划</h2><p>我们的资源是有限的，不可能同时满足所有需求。</p><p>自然我们就需要规划需求，其实这就是评估需求<strong>商业价值</strong>和<strong>优先级</strong>的过程。</p><p>一般的思路为：<strong>基础，引流，连结，筑墙，延伸</strong></p><p>基础，很好理解，一个产品，首先必须是合格的产品才能走向市场。</p><p>引流，使用现有所有资源来寻找用户，使产品尽早达到<strong>网络效应</strong>的<strong>临界点</strong></p><p>连结，将公司的其他产品或是合作公司的应用用产品或场景连结。</p><p>筑墙，构建核心竞争力。</p><p>延伸，拓展业务场景，用户或盈利模式。</p>]]></content>
      
      
      <categories>
          
          <category> 产品研发 </category>
          
          <category> 需求分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品 </tag>
            
            <tag> 需求 </tag>
            
            <tag> 分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>商业模式</title>
      <link href="/2018/09/27/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/09/27/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="商业模式的定义"><a href="#商业模式的定义" class="headerlink" title="商业模式的定义"></a>商业模式的定义</h2><p>关于商业模式，我们先来明确一下定义，下面定义摘自wiki。</p><blockquote><p>商业模式描述的是一个很大范围内正式或非正式的模型，这些模型被公司用来描述商业行为中的不同方面，如<strong>操作流程，组织结构，及金融预测</strong>。虽然这个概念早在20世纪50年代就被提出，但直到20世纪90年代才被广泛接受。在很多商业方面的文献中，这个概念被给与不少非正式的定义。</p><p>商业模型是一个理论工具，它包含大量的<strong>商业元素</strong>及它们之间的关系，并且能够描述特定公司的商业模式。它能显示一个公司在以下一个或多个方面的价值所在：<strong>客户，公司结构</strong>，以及，以<strong>营利和可持续性盈利</strong>为目的，用以<strong>生产，销售，传递价值</strong>及关系资本的<strong>客户网</strong>。</p><p>人们在文献中使用商业模式这一名词的时候，往往模糊了两种不同的含义：一类作者简单地用它来指公司如何从事商业的具体方法和途径，另一类作者则更强调模型方面的意义。这两者实质上是有所不同的：前者泛指一个公司从事商业的方式，而后者指的是这种方式的概念化。后一观点的支持者们提出了一些由要素及其之间关系构成的参考模型（Reference Model），用以描述公司的商业模式。</p></blockquote><p>只有确立了商业模式之后，才能进入商业计划阶段。</p><a id="more"></a><h2 id="如何分析商业模式"><a href="#如何分析商业模式" class="headerlink" title="如何分析商业模式"></a>如何分析商业模式</h2><p>商业模式，也就是一个模型。我们通常由点至面的去分析一个模型。以下是分析商业模式的4个要点。</p><ul><li><strong>基础设施（如何提供）</strong></li><li><strong>产品（提供什么）</strong></li><li><strong>用户/客户（为谁提供）</strong></li><li><strong>财务情况（成本与收益）</strong></li></ul><p>由此展开，我们可以得到一个商业模式框架：</p><p><img src="https://s2.ax1x.com/2019/03/03/kL0rVg.jpg" alt="商业模式框架"></p><p>进而我们就可以画出一张商业模式画布：</p><p><img src="https://s2.ax1x.com/2019/03/03/kLBGLT.jpg" alt="商业模式画布"></p><h3 id="重要概念解释"><a href="#重要概念解释" class="headerlink" title="重要概念解释"></a>重要概念解释</h3><ul><li><p><strong>价值主张</strong>（Value Proposition）：即公司通过其产品和服务所能向消费者提供的<strong>价值</strong>。价值主张<strong>确认了公司对消费者的实用意义</strong>。</p><p>价值主张可能是创新的，表现为一个全新或者破坏性的产品，有一些则与市场现有产品类似，知识增加了一些功能和特性。</p></li><li><p><strong>消费者目标群体</strong>（Target Customer Segments）：即公司所瞄准的消费者群体。这些群体具有某些共性，从而使公司能够（针对这些共性）创造价值。定义消费者群体的过程也被称为<strong>市场划分</strong>（Market Segmentation）。</p><p>客户是任何商业模式的核心。客户体现为独立的客户细分群体，企业需要做出<strong>合理决策</strong>来决定那一部分客户需要<strong>忽略</strong>，哪一部分需要<strong>重视</strong>。</p></li><li><p><strong>渠道通路</strong>（Channels）：即公司用来接触消费者的各种途径。这里阐述了公司如何开拓市场。它涉及到公司的市场和分销策略。</p><p>渠道通路包含以下功能：<strong>提升公司产品和服务在客户人群中的认知、帮助用户评估价值主张、协助客户购买特定产品与服务、向客户传递价值主张、为客户提供售后支持。</strong></p></li><li><p><strong>客户关系</strong>（Customer Relationships）：即公司同其消费者群体之间所建立的联系。我们所说的客户关系管理即与此相关。</p><p>客户关系经常被下列动机驱动：<strong>客户获取、客户维系、提升销售</strong>。</p></li><li><p><strong>价值配置</strong>（Value Configurations）：即资源和活动的配置。例如百度的搜索业务是其核心业务，需要配置大量资源。而像麦肯锡这样的咨询公司，其核心业务是为客户解决问题。</p></li><li><p><strong>核心资源</strong>（Core Resource）：即公司执行其商业模式所需的能力和资源。</p><p>核心资源可以是：<strong>实体资产、金融资产、知识产权、人力资源</strong>。核心资源可以是公司自己持有的，可以是以租借的形式得到的，也可以是从重要伙伴手中获得的。</p></li><li><p><strong>合作伙伴网络</strong>（Partner Network）：即公司同其他公司之间为有效地提供价值并实现其商业化而形成的合作关系网络。这也描述了公司的商业联盟（Business Alliances）范围。</p><p>合作关系可以分为4种类型：<strong>非竞争者之间的合作关系、竞争者之间的合作关系、为开发新业务的合资关系、为确保可靠供应的购买方与供应商的合作关系。</strong></p></li><li><p><strong>成本结构</strong>（Cost Structure）：即所使用的工具和方法的货币描述。</p></li><li><p><strong>收入模型</strong>（Revenue Model）：即公司通过各种收入流（Revenue Flow）来创造财富的途径。</p><p>通常包括：<strong>客户一次性支付获得的交易收入、源于客户为获得价值主张和售后服务所支付的持续性收入</strong></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解 反转字符串(Python3)</title>
      <link href="/2018/07/19/leetcode%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/"/>
      <url>/2018/07/19/leetcode%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p> <strong>说在前面：本题解旨在熟悉python3的基本操作和库函数的使用，仅采用最简便方法，而非时间或空间复杂度较小的方法。若读者想要学习数据结构还是推荐使用C/C++或Java。</strong></p><h2 id="原题："><a href="#原题：" class="headerlink" title="原题："></a>原题：</h2><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p><p><strong>案例:</strong></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;leetcode&quot;</span><br><span class="line">返回 0.</span><br><span class="line"></span><br><span class="line">s = &quot;loveleetcode&quot;,</span><br><span class="line">返回 2.</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong>您可以假定该字符串只包含小写字母。</p><a id="more"></a><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def firstUniqChar(self, s: str) -&gt; int:</span><br><span class="line">        sSet = set(s)</span><br><span class="line">        chaDic = &#123;&#125;</span><br><span class="line">        for i in sSet:</span><br><span class="line">            chaDic[i] = s.count(i)</span><br><span class="line">        for i, j in enumerate(s):</span><br><span class="line">            if chaDic.get(j) == 1:</span><br><span class="line">                return i</span><br><span class="line">        return -1</span><br></pre></td></tr></table></figure><h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><p><strong>set()</strong> 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。</p><p><strong>enumerate()</strong> 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</p><p><strong>count()</strong> 方法用于统计字符串里某个字符出现的次数。可选参数为在字符串搜索的开始与结束位置。</p><p>count()方法语法：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.count(sub, start= 0,end=len(string))</span><br></pre></td></tr></table></figure><ul><li>sub – 搜索的子字符串</li><li>start – 字符串开始搜索的位置。默认为第一个字符,第一个字符索引值为0。</li><li>end – 字符串中结束搜索的位置。字符中第一个字符的索引为 0。默认为字符串的最后一个位置。</li></ul><p>该方法返回子字符串在字符串中出现的次数。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> leetcode </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解 反转字符串(Python3)</title>
      <link href="/2018/07/17/leetcode%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2018/07/17/leetcode%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p> <strong>说在前面：本题解旨在熟悉python3的基本操作和库函数的使用，仅采用最简便方法，而非时间或空间复杂度较小的方法。若读者想要学习数据结构还是推荐使用C/C++或Java。</strong></p><h2 id="原题："><a href="#原题：" class="headerlink" title="原题："></a>原题：</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>char[]</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须<strong>原地修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 <a href="https://baike.baidu.com/item/ASCII" target="_blank" rel="noopener">ASCII</a> 码表中的可打印字符。</p><a id="more"></a><p><strong>示例 1：</strong></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseString(self, s: List[str]) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify s in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        for i in range(len(s)):</span><br><span class="line">            if i&gt;= len(s)/2:</span><br><span class="line">                break</span><br><span class="line">            s[i],s[-i-1] = s[-i-1],s[i]</span><br><span class="line">            #也可以直接写s[:]=s[::-1]，最简单的写法。</span><br></pre></td></tr></table></figure><h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><p><strong>s[i],s[-i-1] = s[-i-1],s[i]</strong></p><p>相当于C和Java中的：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int temp = s[i];</span><br><span class="line">s[i] = s[-i-1];</span><br><span class="line">s[-i-1] = temp;</span><br></pre></td></tr></table></figure><p>简单的交换。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> leetcode </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解 旋转图像(Python3)</title>
      <link href="/2018/07/13/leetcode%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
      <url>/2018/07/13/leetcode%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<p> <strong>说在前面：本题解旨在熟悉python3的基本操作和库函数的使用，仅采用最简便方法，而非时间或空间复杂度较小的方法。若读者想要学习数据结构还是推荐使用C/C++或Java。</strong></p><h2 id="原题："><a href="#原题：" class="headerlink" title="原题："></a>原题：</h2><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><p><strong>说明：</strong></p><p>你必须在<strong>原地</strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix = </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix =</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def rotate(self, matrix: List[List[int]]) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify matrix in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        matrix[:]=map(list,zip(*matrix[::-1]))</span><br></pre></td></tr></table></figure><h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><p><strong>matrix[:]</strong> 表示重新生成matrix中的元素，若仅使用matrix并不会改变matrix中的元素。</p><p><strong>map</strong></p><blockquote><p><code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回。</p><p>举例说明，比如我们有一个函数f(x)=x2，要把这个函数作用在一个list <code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code>上，就可以用<code>map()</code>实现如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;             f(x) = x * x</span><br><span class="line">&gt; </span><br><span class="line">&gt;                   │</span><br><span class="line">&gt;                   │</span><br><span class="line">&gt;   ┌───┬───┬───┬───┼───┬───┬───┬───┐</span><br><span class="line">&gt;   │   │   │   │   │   │   │   │   │</span><br><span class="line">&gt;   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼</span><br><span class="line">&gt; </span><br><span class="line">&gt; [ 1   2   3   4   5   6   7   8   9 ]</span><br><span class="line">&gt; </span><br><span class="line">&gt;   │   │   │   │   │   │   │   │   │</span><br><span class="line">&gt;   │   │   │   │   │   │   │   │   │</span><br><span class="line">&gt;   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼</span><br><span class="line">&gt; </span><br><span class="line">&gt; [ 1   4   9  16  25  36  49  64  81 ]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>zip</strong></p><blockquote><p><strong>zip()</strong> 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。</p><p>我们可以使用 list() 转换来输出列表。</p><p>如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 <strong>*</strong> 号操作符，可以将元组解压为列表。</p></blockquote><p>关于zip更多详细信息和实例：<a href="https://www.programiz.com/python-programming/methods/built-in/zip" target="_blank" rel="noopener">https://www.programiz.com/python-programming/methods/built-in/zip</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解 搜索二维矩阵 II(Python3)</title>
      <link href="/2018/07/12/leetcode%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%20II/"/>
      <url>/2018/07/12/leetcode%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%20II/</url>
      
        <content type="html"><![CDATA[<p> <strong>说在前面：本题解旨在熟悉python3的基本操作和库函数的使用，仅采用最简便方法，而非时间或空间复杂度较小的方法。若读者想要学习数据结构还是推荐使用C/C++或Java。</strong></p><h2 id="原题："><a href="#原题：" class="headerlink" title="原题："></a>原题：</h2><p>编写一个高效的算法来搜索 <em>m</em> x <em>n</em> 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p><ul><li>每行的元素从左到右升序排列。</li><li>每列的元素从上到下升序排列。</li></ul><p><strong>示例:</strong></p><p>现有矩阵 matrix 如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>给定 target = <code>5</code>，返回 <code>true</code>。</p><p>给定 target = <code>20</code>，返回 <code>false</code>。</p><a id="more"></a><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def searchMatrix(self, matrix, target):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type matrix: List[List[int]]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not matrix:</span><br><span class="line">            return False</span><br><span class="line">        i = 0</span><br><span class="line">        j = len(matrix[0]) - 1</span><br><span class="line">        while i &lt; len(matrix) and j &gt;= 0:</span><br><span class="line">            if matrix[i][j] == target: </span><br><span class="line">                return True</span><br><span class="line">            elif matrix[i][j] &gt; target: </span><br><span class="line">                j -= 1</span><br><span class="line">            else: </span><br><span class="line">                i += 1</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><p>很简单的从右上角开始自上而下 从右向左的搜索。</p><p>如果要更高的效率可以使用二分查找。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解 合并两个有序数组(Python3)</title>
      <link href="/2018/07/12/leetcode%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
      <url>/2018/07/12/leetcode%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p> <strong>说在前面：本题解旨在熟悉python3的基本操作和库函数的使用，仅采用最简便方法，而非时间或空间复杂度较小的方法。若读者想要学习数据结构还是推荐使用C/C++或Java。</strong></p><h2 id="原题："><a href="#原题：" class="headerlink" title="原题："></a>原题：</h2><p>给定两个有序整数数组 <em>nums1</em> 和 <em>nums2</em>，将 <em>nums2</em> 合并到 <em>nums1</em> 中<em>，</em>使得 <em>num1</em> 成为一个有序数组。</p><p><strong>说明:</strong></p><ul><li>初始化 <em>nums1</em> 和 <em>nums2</em> 的元素数量分别为 <em>m</em> 和 <em>n</em>。</li><li>你可以假设 <em>nums1</em> 有足够的空间（空间大小大于或等于 <em>m + n</em>）来保存 <em>nums2</em> 中的元素。</li></ul><p><strong>示例:</strong></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify nums1 in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        cnt = len(nums1)</span><br><span class="line">        for n in nums1[::-1]:</span><br><span class="line">            if(cnt==m):</span><br><span class="line">                    break</span><br><span class="line">            if n==0:</span><br><span class="line">                nums1.pop(len(nums1)-1)</span><br><span class="line">                cnt-=1</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line">        nums1[:]=sorted(nums1+nums2)</span><br></pre></td></tr></table></figure><h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><p><strong>for n in nums1[::-1]:</strong>从尾至头进行循环</p><p><strong>num[:]</strong> 表示重新生成num函数中的函数，若仅使用num并不会改变num中的元素。<br><strong>list.pop()</strong>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解 从排序数组中删除重复项(Python3)</title>
      <link href="/2018/07/12/leetcode%20%E4%BB%8E%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>/2018/07/12/leetcode%20%E4%BB%8E%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p> <strong>说在前面：本题解旨在熟悉python3的基本操作和库函数的使用，仅采用最简便方法，而非时间或空间复杂度较小的方法。若读者想要学习数据结构还是推荐使用C/C++或Java。</strong></p><h2 id="原题："><a href="#原题：" class="headerlink" title="原题："></a>原题：</h2><p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeDuplicates(self, nums: List[int]) -&gt; int:</span><br><span class="line">        nums[:] = sorted(set(nums))</span><br><span class="line">        return len(nums)</span><br></pre></td></tr></table></figure><h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><p><strong>num[:]</strong> 表示重新生成num函数中的函数，若仅使用num并不会改变num中的元素。</p><p><strong>sorted()</strong> 函数对所有可迭代的对象进行排序操作。</p><blockquote><p><strong>sort 与 sorted 区别：</strong></p><p>sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。</p><p>list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。</p></blockquote><p>sorted 语法：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sorted(iterable, key=None, reverse=False)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>iterable – 可迭代对象。</li><li>key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</li><li>reverse – 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。</li></ul><p><strong>集合（set）</strong>是一个无序的不重复元素序列。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用</span><br><span class="line">s = &#123;value01,value02,...&#125;</span><br><span class="line">或者</span><br><span class="line">set(value)</span><br><span class="line">创建一个集合</span><br></pre></td></tr></table></figure><p>更多集合操作可参考官方文档：</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互联网产品几个规律及特点</title>
      <link href="/2018/06/23/%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E7%89%B9%E7%82%B9/"/>
      <url>/2018/06/23/%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E7%89%B9%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="联网产品的几个规律"><a href="#联网产品的几个规律" class="headerlink" title="联网产品的几个规律"></a>联网产品的几个规律</h2><p><strong>产品价值守恒：</strong>长期来看，产品的使用价值与产品所带来的商业价值相等。</p><p><strong>产品复杂度守恒：</strong>用户交互越复杂，开发工作量越小，用户交互越简单，开发工作量越大。</p><p><strong>互联网产品的商业模式：</strong><br>    低者为王：金字塔结构，赚的大多是三低人群的钱。（娱乐 低龄 低收入）<br>    用户体验低门槛为王：对用户要求低，谁都能用，有效提高用户数量、<br>    印钞机式赚钱：吃软饭，赚硬钱（随着用户增加，利润明显增加，但成本增加不大）etc.世纪佳缘 获得信息，真爱网 需要红娘，属于劳动密集型产业</p><p><strong>诺威格定律：</strong>当公司市场占有率达到50%以上时，市场占有率就无法再翻番了。 所以大公司往往扩展其他业务提升利润。<br><strong>越成功的公司越难拐弯：</strong>在某一领域特别成功的公司，其公司文化、商业模式、管理机制等已经被优化的极度适应当前领域。若想要进入新的市场就会变得难以适应。因此现在<br>一些大公司都会有独立子公司或者独立工作室来减小这种影响。<br><strong>顺势而为：</strong>行业分析。</p><a id="more"></a><h2 id="联网产品的几个特点"><a href="#联网产品的几个特点" class="headerlink" title="联网产品的几个特点"></a>联网产品的几个特点</h2><p><strong>互联网产品的交互性：</strong><br>凯文凯利曾举过一个例子来描述这个特性，他说蜜蜂要觉得去哪儿采蜜时所做的决策并不是由蜂后来决定的，而是由无数的蜜蜂去探索之后，将好的坏的情况的信息带回，然后再由一波蜜蜂去验证，如此循环之后，就可以做出一个不错的决定。这就是典型的信息交互。互联网产品与传统产品最大的不同点就在于信息的交互。当产品上线之后，产品经理可以得到非常快速的及时的<strong>信息反馈</strong>。<br><strong>高固定成本，低边际成本：</strong><br>吃软饭，赚硬钱（随着用户增加，利润明显增加，但成本增加不大）<br><strong>网络效应：</strong><br>用户量可以提升产品本身的价值量，用户也是产品的一部分。IM产品尤为明显（QQ，微信，随着用户群体增加，产品的<strong>商业价值</strong>快速上升）。价值量提升基于用户数量和和产品<strong>规则设计</strong>，同样的用户数量，良好的规则设计可以带来更多的价值提升。因此，应当尽快增<strong>加用户数量</strong>，设计产品使产品的网络效应的<strong>临界点</strong>更小，并且尽快先于对手达到<strong>临界点</strong>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>产品经理怎么做数据分析</title>
      <link href="/2018/06/23/%E5%B8%82%E5%9C%BA%E8%B0%83%E7%A0%94%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
      <url>/2018/06/23/%E5%B8%82%E5%9C%BA%E8%B0%83%E7%A0%94%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>PM需要分析的数据，一般都是市场数据，所以大家一般也把这个过程叫做市场调研。</p><h2 id="为什么要做市场调研"><a href="#为什么要做市场调研" class="headerlink" title="为什么要做市场调研"></a>为什么要做市场调研</h2><p>一般公司都有marketing部门帮助PM完成这项工作，但是这并不代表我们不需要学习它了。从原理上理解我们的工作是十分重要的，就像搞数据分析的人可以用matlab、可以用R写脚本但还是得学好基本的数学一样。</p><a id="more"></a><h2 id="做市场调研的基本方法"><a href="#做市场调研的基本方法" class="headerlink" title="做市场调研的基本方法"></a>做市场调研的基本方法</h2><p>先上个例子。cesim公司的市场调研报告的目录。</p><p><img src="https://s2.ax1x.com/2019/02/15/krJoC9.md.jpg" alt="cesim市场调研报告目录"></p><p>其中市场调研部分包括广告效应、销售预测、影响用户购买决策的产品特性、渠道投资、PDA特征喜好。那么为什么企业要调查这些指标呢？</p><ol><li><h3 id="明确目标"><a href="#明确目标" class="headerlink" title="明确目标"></a>明确目标</h3><p>做市场调研之前，首先要明确我们想搞清楚的问题是什么。一般对于to c的产品，常用5W1H法（六何分析法）。</p><h3 id="以互联网产品为例（用户导向）："><a href="#以互联网产品为例（用户导向）：" class="headerlink" title="以互联网产品为例（用户导向）："></a>以互联网产品为例（用户导向）：</h3><p>Who: <strong>目标用户</strong>是什么样的<br>When：用户使用产品的<strong>时间</strong>（行为习惯）<br>What：用户会<strong>做什么</strong><br>Where：用户使用的<strong>场景</strong><br>Why：用户<strong>需求</strong></p><p>How：用户执行任务或达到目标所使用的具体方法<br>简而言之就是，什么样的人 在什么时间 什么场景 用什么样的设备 干什么样的事情 以及是怎么干的。</p><h3 id="以传统生产行业为例（产品导向）："><a href="#以传统生产行业为例（产品导向）：" class="headerlink" title="以传统生产行业为例（产品导向）："></a>以传统生产行业为例（产品导向）：</h3></li></ol><table><thead><tr><th></th><th>现状</th><th>原因</th><th>如何改善</th></tr></thead><tbody><tr><td><strong>对象（What）</strong></td><td>现在的产品是怎样的</td><td>为什么生产这个产品</td><td>工艺改良？能不能生产别的？</td></tr><tr><td><strong>目的（Why）</strong></td><td>生产的原因</td><td>为什么是这个目的</td><td>能不能是别的目的</td></tr><tr><td><strong>场所（Where）</strong></td><td>在哪儿做</td><td>为什么在那儿干</td><td>有没有更好的场所</td></tr><tr><td><strong>时间（When）</strong></td><td>什么时候做</td><td>为什么是这个时候</td><td>有没有更好的时间</td></tr><tr><td><strong>作业员（Who）</strong></td><td>谁来做</td><td>为什么是这样的人</td><td>有没有更好的人选</td></tr><tr><td><strong>方法（How）</strong></td><td>怎么做</td><td>为什么这么做</td><td>能不能改进现有的方法</td></tr></tbody></table><p>   可见虽然两者思考的东西不同，但仍可用相同的方式思考。</p><p>   市场经济时代大家都很注重成本，于是又提出了一个How much,变成了5W2H。</p><p>   可扩为下图</p><p>   <img src="https://s2.ax1x.com/2019/02/15/kr31ts.png" alt="5W2H分析法"></p><ol start="2"><li><h3 id="设计调研方法（主要部分）"><a href="#设计调研方法（主要部分）" class="headerlink" title="设计调研方法（主要部分）"></a>设计调研方法（主要部分）</h3></li></ol><p>那么，如何去填补我们不知道的部分？就和做其他任何研究一样，这一步必须明确调研的方法。  一般有竞品分析、行业分析、需求分析、数据收集等方面。</p><ol start="3"><li><h3 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h3><p>根据方法目标和具体调查对象等因素，收集数据，分析数据。这些会在数据分析部分着重讨论。 </p></li><li><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>得出结果。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>产品经理怎么做数据分析</title>
      <link href="/2018/06/23/%E7%AB%9E%E5%93%81%E5%88%86%E6%9E%90/"/>
      <url>/2018/06/23/%E7%AB%9E%E5%93%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>PM需要分析的数据，一般都是市场数据，所以大家一般也把这个过程叫做市场调研。</p><h2 id="为什么要做市场调研"><a href="#为什么要做市场调研" class="headerlink" title="为什么要做市场调研"></a>为什么要做市场调研</h2><p>一般公司都有marketing部门帮助PM完成这项工作，但是这并不代表我们不需要学习它了。从原理上理解我们的工作是十分重要的，就像搞数据分析的人可以用matlab、可以用R写脚本但还是得学好基本的数学一样。</p><a id="more"></a>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>用户与场景</title>
      <link href="/2018/06/02/%E7%94%A8%E6%88%B7%E4%B8%8E%E5%9C%BA%E6%99%AF/"/>
      <url>/2018/06/02/%E7%94%A8%E6%88%B7%E4%B8%8E%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>在分析用户需求的时候，我们首先要明确：<strong>用户与场景是紧密联系的，不同人在不同场景下的行为是不同的。</strong></p><h2 id="分析方法"><a href="#分析方法" class="headerlink" title="分析方法"></a>分析方法</h2><p>这里写的方法是基于快速迭代的思路，这里我把方法分为五步：</p><a id="more"></a><h3 id="1-寻找用户"><a href="#1-寻找用户" class="headerlink" title="1.寻找用户"></a>1.寻找用户</h3><p>这部分用户在产品起步阶段，大致的划分出的目标客户。可能是天使用户，也可能是探索者或是geek。不必太精细，因为后续步骤会将用户继续细化（真正的客户会被验证）。</p><h3 id="2-场景"><a href="#2-场景" class="headerlink" title="2.场景"></a>2.场景</h3><p>在不同场景使用产品必然有不同的需求，例如在火车站绝大部分人需要吃快餐，所以不会有西餐厅开在火车站内，在地铁上手机信号不不好，所以QQ空间现在也支持离线发说说了。</p><h3 id="3-找到问题（需求）"><a href="#3-找到问题（需求）" class="headerlink" title="3.找到问题（需求）"></a>3.找到问题（需求）</h3><p>在确定了用户和场景之后，通过排列组合，我们可以列出很多需求。并且提出<strong>假设</strong>。</p><h3 id="4-验证假设"><a href="#4-验证假设" class="headerlink" title="4.验证假设"></a>4.验证假设</h3><p>假设不一定是正确，当然我们需要去验证。错误的方向只能带来浪费。验证的方式有很多，在产品初期最低成本低风险的方案当属<strong>用户访谈</strong>（这方面后续会写）。</p><h3 id="5-解决方案"><a href="#5-解决方案" class="headerlink" title="5.解决方案"></a>5.解决方案</h3><p>在完成上述步骤后，最终我们就应该有能做出解决用户在某些场景下需求的功能或方案。最终将我们的产品推向市场，然后从步骤1继续循环，这就是<strong>迭代</strong>。这里需要注意，一个产品的生命周期是<strong>有限的</strong>，如果不能在有限的时间内<strong>迭代足够多的次数</strong>，产品就会不成熟，影响收益。就像青春是有限的，如果一个人在年轻力壮没有好好努力的话，就会老大徒伤悲。</p><h2 id="关于用户的几个要点"><a href="#关于用户的几个要点" class="headerlink" title="关于用户的几个要点"></a>关于用户的几个要点</h2><p>用户不一定能为你创造价值，但是客户一定出自用户。这里我们就应该尽可能的拓展用户数量，尽可能的提高用户转换为客户的转换率。</p><p>学会换位思考，多从用户的角度想问题，这样能提出更靠谱的假设，也可能带来一些新的灵感。</p><p>用户划分一定要足够细致，用户对产品的依赖越强，就越有可能盈利。这一条带来的就是转化率这个指标的提高。</p><p>出现问题太多，没有重点的时候，应当思考是不是用户划分不够细致，用户过于散乱。现在精准流量与泛流量的概念很好的解释了这点。精准流量的抖音账号，10W+粉打个广告也差不多10W，而泛流量的账号，100W粉才差不多这个价钱。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>行业发展因素分析</title>
      <link href="/2018/05/20/%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%90/"/>
      <url>/2018/05/20/%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>进入一个行业，或是做一个产品，都要考虑这个行业整体的状况。爬楼梯再努力，也没坐电梯的快，一个简单的选择的问题。行业端是高于市场端的，宏观的行业分析正确，可以包容微观执行的不利。下面粗略罗列了一些影响行业分析的因素，以供参考。</p><a id="more"></a><h2 id="行业发展因素分析"><a href="#行业发展因素分析" class="headerlink" title="行业发展因素分析"></a>行业发展因素分析</h2><h3 id="行业发展因素分析的内容："><a href="#行业发展因素分析的内容：" class="headerlink" title="行业发展因素分析的内容："></a>行业发展因素分析的内容：</h3><p>1、行业在社会经济中的地位分析。行业在社会经济中的地位，主要表现在三个方面：</p><p>　　（1）行业的产值（净产值和总产值）、利税额及吸收劳动力的数量，在全国工业产值、财政收入和就业总量中所占的比重；</p><p>　　（2）行业的现状和未来对整个社会经济及其他行业发展的影响程度；</p><p>　　（3）行业在国际市场上的竞争、创汇能力分析。行业的产品收入弹性也能说明行业在社会经济中的地位。其公式如下：</p><p>　　某行业的产品收入弹性系数=某行业产品的需求增长率/人均国民收入的增长率若弹性系数大于1，说明这种行业在产业结构中能够占有更大的份额，有更广阔的发展余地。</p><p>　　在分析行业社会经济地位时，确定行业是否是社会经济发展的主导行业是非常重要的。</p><p>　　2、行业特性分析。</p><p>　　行业特性是由于各行业由于其使命，发展条件以及产品和生产过程方面的不同而使各行业具有的不同性质。行业特性分析有助于把握行业的特点，了解行业环境。行业特性分析可以从以下几个方面入手：</p><p>　　（1）从行业分工来确定行业的特性。行业内存在着的纵横的分工关系界定了每个企业在本行业中的经营范围，决定了每个企业与其他企业的分工关系。</p><p>　　（2）从行业在工业生产中的位置来分析行业的性质。</p><p>　　（3）从行业所使用的资源和技术来分析，可分为劳动密集型行业、资金密集型行业和技术密集型行业。</p><p>　　（4）从行业所需资源的可靠性和及时性来进行分析，比如说行业依靠的是农产品则行业的变化将受到天气变化的影响。</p><p>　　（5）从行业技术发展趋势及前景、技术进步状况进行分析。</p><p>　　3、行业规模结构分析。</p><p>　　一类是悬殊型，即一个行业内大企业处于领导地位，小企业和大企业在规模和实力上相差很大，行业内竞争不甚激烈；</p><p>　　第二类是均衡型，行业内各企业之间势均力敌，竞争十分激烈。在进行行业规模结构分析的时候，一定要分析行业内几家大企业的经营状况，因为他们的行动会对行业的发展及利润起主导作用，分析他们的经营思想、经营战略、产品特色、技术水平、竞争能力及市场占有率及其优劣势等因素，对行业的环境分析具有十分重要的意义。</p><p>　　4、行业数量结构分析。</p><p>　　一般来讲，市场规模大，企业数量就多，行业内集中程度低，大企业少。反之，市场规模小，企业数量就少，行业集中程度高，大企业就多。</p><p>　　5、行业组织结构分析。</p><p>　　应对行业内企业联合的状况进行分析，对联合与竞争的趋势进行估计和<a href="https://wiki.mbalib.com/wiki/%E9%A2%84%E6%B5%8B" target="_blank" rel="noopener">预测</a>。</p><p>　　6、行业市场结构分析。</p><p>　　从行业供求关系来看，基本上可以分为三类，即供不应求、供求平衡和供大于求。若供大于求，则企业间的竞争激烈，可能导致价格下跌和高额的销售费用支出，有的企业可能会发生亏损；若供小于求，则各企业产品都可以找到合适的市场，价格相对稳定，新企业会大量涌入本行业。同时，还应对行业市场的需求分布状态、对行业产品需求变动的频繁性进行分析。</p><p>　　7、行业社会环境方面的限制分析。</p><p>　　行业发展过程中，应当防止对空气、森林、水源、地貌等自然环境的污染，这些因素将会对行业的发展起限制作用。</p><p>　　以上讨论的七个因素都是相互联系的，每个方面的变化都会引起其它方面的变化，因此在分析行业发展变化时，必须注意抓好关键信息，以便企业领导人能及时恰当的作出反应。</p><p>　　行业社会环境方面的限制分析。行业发展过程中，应当防止对空气、森林、水源、地貌等自然环境的污染，这些因素将会对行业的发展起限制作用。以上讨论的七个因素都是相互联系的，每个方面的变化都会引起其它方面的变化，因此在分析行业发展变化时，必须注意抓好关键信息，以便企业领导人能及时恰当的作出反应。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>想要成为PM要怎么起步？</title>
      <link href="/2018/05/13/%E6%83%B3%E8%A6%81%E6%88%90%E4%B8%BAPM%E8%A6%81%E6%80%8E%E4%B9%88%E8%B5%B7%E6%AD%A5%EF%BC%9F/"/>
      <url>/2018/05/13/%E6%83%B3%E8%A6%81%E6%88%90%E4%B8%BAPM%E8%A6%81%E6%80%8E%E4%B9%88%E8%B5%B7%E6%AD%A5%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>想要解答一个问题的方法，从小学开始老师就已经教授过了。首先我们得知道<strong>定义</strong>，然后从定义出发，发掘我们所需要的<strong>条件</strong>。</p><h2 id="什么是PM"><a href="#什么是PM" class="headerlink" title="什么是PM"></a>什么是PM</h2><blockquote><p><strong>产品经理</strong>（英文：<strong>Product manager</strong>，缩写：<strong>PM</strong>）也称<strong>产品企划</strong>，是指在公司中针对某一项或是某一类的产品进行规划和管理的人员，主要负责产品的研发、制造、营销、渠道等工作。产品经理是很难定义的一个角色，如果非要一句话定义，那么产品经理是为终端用户服务，负责产品整个生命周期的人。——维基百科</p></blockquote><a id="more"></a><h2 id="PM得技能组成"><a href="#PM得技能组成" class="headerlink" title="PM得技能组成"></a>PM得技能组成</h2><p>有产品的地方就有产品经理，就算在相同行业，对产品经理的要求也不太相同<del>（一般都是因为对应岗位没人，PM顶上）</del>。但是产品经理的核心能力是确实不变的，只是在不同行业内形式有些差别。下面我总结了一个导图，叶子节点不一定很全面，主要在于抓住上一层的<strong>核心技能</strong>。掌握核心能力，就是我们得出答案的条件。</p><p><img src="https://s2.ax1x.com/2019/02/15/kD0qVx.png" alt="PM技能树"></p><p>就像RPG游戏一样打怪升级点技能树，PM的技能树就是根据<strong>核心能力</strong>结合所处行业的不通过要求得来得叶子节点。举个例子，比如互联网PM，想要点亮<strong>运营策略</strong>这个技能，就必须先学会<strong>活动策划、提供内容、用户调研、推广渠道</strong>这几项技能。</p><h2 id="从哪里开始"><a href="#从哪里开始" class="headerlink" title="从哪里开始"></a>从哪里开始</h2><p>俗话说的好 缺什么补什么，少什么添什么（张宇语录）。首先我们应挑选一个自己最感兴趣的技能去学习，这样能减少一些挫败感多一些成就感。喜欢数据分析的就可以从数据分析入手，喜欢运营的就从运营入手。</p><p>但强调一点，作为PM得学会把握趋势，大数据时代，<strong>数据分析</strong>是大势所趋。在我看来PM更靠近决策者，PM得每项技能都有职业可以代替，数据分析有数据分析师，产品运营有运营，研发有项目经理。PM该做的事情是从市场数据中提炼出市场需求，根据需求提出一个产品。一专多强的模式是很适合PM的。这一专，便是<strong>数据分析</strong>。</p><p>即便<strong>数据分析</strong>是那么的重要，但在本博客我们从<strong>市场</strong>入手来学习如何做一个优秀的PM。当我们对市场和运营有所了解之后，对于为什么要数据分析这个问题，就可以有一个很直觉的答案了。小时候学数学，不知道为什么要学，那个痛苦啊。当你需要它的时候，相信我，它会变得可爱动人。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="关于这个博客和我"><a href="#关于这个博客和我" class="headerlink" title="关于这个博客和我"></a><strong>关于这个博客和我</strong></h1><h3 id="我为什么要写这个博客"><a href="#我为什么要写这个博客" class="headerlink" title="我为什么要写这个博客"></a>我为什么要写这个博客</h3><p>本博客记录博主的一些所思所想和学习经历，是博主整理自己脑内知识条理的一种方式，有条理的复刻自己脑内的知识体系。但碍于时间，仅记录了博主一部分的知识。希望在更远的将来，能记录下更多。</p><h3 id="我想做PM的原因"><a href="#我想做PM的原因" class="headerlink" title="我想做PM的原因"></a>我想做PM的原因</h3><p>在博主小时候，跟很多贪玩男孩一样，总是想做一些新奇的玩具。长大一点呢，觉得有技术才能做自己想要的东西，故选择了技术之路。随着慢慢对社会、工业和商业方面的了解，博主发现一般人都是帮别人做别人的东西，自己想做的东西呢，单凭自己也做不出来。那作为老板就能随便做自己想要的产品吗？那当然也不是。老板不根据市场需求来做产品，最终不能盈利的话，这个产品最后还是得凉凉。</p><p>世上没有谁是能完全随心所欲的。所以我想，我能不能根据市场需求加入一点自己的想法去做一个东西，这样我便萌生了做产品经理的想法。</p><p>​       </p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Categories</title>
      <link href="/Categories/index.html"/>
      <url>/Categories/index.html</url>
      
        <content type="html"><![CDATA[<p>A<br>B</p>]]></content>
      
    </entry>
    
    
  
</search>
